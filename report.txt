შესრულებული მოთხოვნები
  მთავარი მოთხოვნები
    პირველი 4 ტექნიკა (Basic Techniques)
    გადარჩევით ძებნა
  დამატებითი მოთხოვნები
    Basic technique 5
    Advanced technique 1
    Advanced technique 2

Main.hs
  იღებს გადაცემულ string-ების მასივს
  თუ input ვალიდურია გადააკონვერტირებს Helpers.hs-ში აღწერილ grid-ად
  Grid-ის თითოეული უჯრა შეიძლება იყოს X, O, ცარიელი E (წერტილი), ან უცნობი N (რატომ, არ ვიცი)
  grid გადაეცემა TTL.hs-ში აღწერილ gridSolvers
  თუ gridSolver-მა წარმატებით ამოხსნა დააბრუნებს ამონახსნს
  წინააღმდეგ შემთხვევაში გვიწერს, input იყო არავალიდური თუ ამონახსნი არაა აქვს

TTL.hs
  gridSolver
    ხსნის ტექნიკების (techSolver) გამოყენებით, თუ დაფა არ შეივსო სვამს ერთ სიმბოლოს გადარჩევით (bruteForce)
    techSolver
      5 ტექნიკა (lineSolver) მუშაობს მხოლოდ ზოლებზე და იმაპება თითოეულ ზოლზე
      2 ტექნიკას (avoidDuplication, advancedTech2) სჭირდება სხვა ზოლების ცოდნაც და იმაპება მთელს დაფაზე
      ეს ტექნიკები გამოიყენება სანამ დაფა იცვლება
      სვეტებზე სამოქმედოდ doOnRowsCols იყენებს transpose ფუნქციას
    bruteForce
      Bool არგუმენტი არის რათა რიგრიგობით სცადოს X და O
      dfs-ით ცდილობს ჯერ X-ის მერე O-ის რიგრიგობით ჩასმას პირველივე უჯრაში
      თუ დაფა არავალიდურია ან ვერ შეივსო უბრუნდება წინა ვერსიას და ცდილობს მეორეს ჩასმას

Solvers.hs
  avoidTriple1
    pattern matching-ით ეძებს ორ ერთნაირ სიმბოლოს გვერდიგვერდ და სვამს საპირისპიროს მათ გვერდებზე
  avoidTriple2
    pattern matching-ით ეძებს ორ ერთნაირ სიმბოლოს ერთი უჯრის დაშორებით და სვამს საპირისპიროს მათ შუაში
  avoidTriple3
    remainXO-ს საშუალებით ვიგებთ რამდენი X და O დაგვრჩა ჩასასმელი ზოლში
    ტექნიკა მოქმედებს, როცა ზოლში გვაქს ერთი X (O) ჩასასმელი ხოლო მეორე - O (X) - ერთზე მეტია
    ჩასასმელი სიმბოლო, რომელიც ერთი გვაქვს აღნიშნულია charToGuess-ით ხოლო მეორე otherChar-ით
    მიღებული ზოლის წერტილებზე ფუნქციამ უნდა და-spread-ოს რამე კომბინაცია, რომელიც უეჭველად სწორია
    კომბინაცია არის ყველა შესაძლო სიმბოლოს თანმიმდევრობა, რომელიც შესაძლოა დაი-spread-ოს ზოლზე
    fillVariants-ის საშუალებით ვიგებთ ვალიდურ და არავალიდურ კომბინაციებს
      რომლებიც არ ქმნიან სამიანებს (XXX, OOO)
    თუ ვალიდური კომბინაციებიდან მხოლოდ ერთი გვაქვს, ესე იგი მხოლოდ ერთი ამონახნსი აქვს და ვსვამთ მაგას
    თუ არავალიდური კომბინაციები გვაქს ვაკეთებთ შემდეგს
      გვინდა, ყველაგან, სადაც charToGuess X (O) ვერ ჩაისმევა, ჩავსვათ საპირისპირო - O (X)
      ყველა კომბინაციას ვუკეთებთ invert-ს
        ვითვალისწინებთ, რომ თუ უჯრაში ერთი დარჩენილი X (O) არ ისმევა, აუცილებლად ჩაისმევა O (X)
        charToGuess-ს, რომელიც ერთი გვაქს ვცვლით საპირისპიროთი, ხოლო დანარჩენს ცარიელით
      არავალიდურ inverted კომბინაციებს ვაერთიანებთ merge-ით და ვუკეთებთ spread-ს ზოლის წერტილებზე
  completeLine
    ვითვალისწინებთ, რომ X-ებისა და O-ის რაოდენობა უნდა იყოს ტოლი
    remainXO-თი ვიგებთ რამდენი X და O დარჩა ჩასასმელი და ვსვავთ რომელიც დაგვრჩა (არ უდრის ნულს)
  avoidDuplication
    ტექნიკა მოქმედებს მთლიან დაფაზე, და როცა ზოლში დაგვრჩა ორი უჯრა შესავსები
    სანამ დაფა იცვლება სტრიქონებსა და სვეტებზე კეთდება შემდეგი
      fillVariants2-ის საშუალებით ვიგებთ ვალიდურ და არავალიდურ კომბინაციებს, spread-ისთვის
        რომლებიც არ ქმნიან სამიანებსა (XXX, OOO) და დუპლიკატებს
      თუ ვალიდური მხოლოდ ერთი ვარიანტია ესე იგი, ვუკეთებთ spread-ს მაგ კომბინაციით
  avoidTech1
    ტექნიკა მოქმედებს, როცა ზოლში დარჩენილია შესავსები მხოლოდ 2 X (O) და 2-ზე მეტი O (X)
    onlyValidSpread-ით ვიგებთ, თითოეულ უჯრაში რა უნდა ჩაისვას აუცილებლად, რათა ავირიდოთ სამიანები
      fillVariants-ით ვიგებთ, შესაძლო ვალიდურ და არავალიდურ კომბინაციებს
      listCommons-ით ვიგებთ, list-ებიდან რა სიმბოლო გვხვდება თითოეულ პოზიციაზე
      oneHasOtherNot-ით ვიგებთ, რა აქვს მხოლოდ ერთ ლისტს და არა - მეორეს
      ამ helper-ების დახმარებით, ვიგებთ, თითოეულ ცარიელ უჯრაში რა არის ერთადერთი შესაძლო ჩასმა
        თითოეულ უჯრაში ვიგებთ, თუ გვაქვს სიმბოლო, რომელიც აქ მხოლოდ არავალიდურ ვარიანტებს გვაძლევ
        თუ ამ უჯრაში X (O) გვხვდება მხოლოდ არავალიდურებში, ესე იგი, უნდა ჩავსვათ O (X)
    მაგალითი
      l = [O,E,E,O,E,E,X,E,E,O]
      (vs, is) = fillVariants l
      vs = [[X,X,X,O,X,O],[X,X,X,O,O,X],[X,X,O,X,O,X]]
      is = [
        [X,X,X,X,O,O],[X,X,O,X,X,O],[X,X,O,O,X,X],[X,O,X,X,X,O],[X,O,X,X,O,X],[X,O,X,O,X,X],
        [X,O,O,X,X,X],[O,X,X,X,X,O],[O,X,X,X,O,X],[O,X,X,O,X,X],[O,X,O,X,X,X],[O,O,X,X,X,X]
      ]
      listCommons is = [[X,O],[X,O],[X,O],[X,O],[X,O],[X,O]]
      listCommons vs = [[X],[X],[X,O],[X,O],[X,O],[X,O]]
      zipped = zipWith oneHasOtherNot (listCommons is) (listCommons vs) = [[O],[O],[],[],[],[]]
      spreadComb = map (\cs -> if length cs == 1 then reverseChar (head cs) else E) zipped
      spreadComb = [X,X,E,E,E,E]
      spread spreadComb l = [O,X,X,O,E,E,X,E,E,O]
      o..o..x..o -> oxxo..x..o
  avoidTech2
    avoidDuplication-ივით მომედებს მთლიან დაფაზე, ოღონდ როცა უმცირესი დარჩენილი სიმბოლო ერთია
      გადაუვლის ყველა სტრიქონსა და სვეტს სანამ შეუძლია შეცვალოს დაფა
    avoidTech1-ივით იყენებს onlyValidSpread-ს, ოღონდ განახლებულ ვერსიას
      onlyValidSpread2 ითვალისწინებს დუპლიკატებსაც
      ისევ ეძებს სიმბოლოს რომელიც ამ პოზიციაზე გვხვდება მხოლოდ არავალიდურებში და ანაცვლებს პირიქით

Helpers.hs
  კოდში თითოეულ ფუნქციას აქვს აღწერა კომენრტარის სახით

სისწორესა და წარმადობაში დავრწმუნდი ამის შემდეგ
  ფუნქციების ცალ ცალკე გაანალიზება და მაგალითებზე შემოწმება
  conceptispuzzles-ის აპლიკაციით ბევრი რთული პაზლების ამოხსნა
